
# 重学「从URL输入到页面渲染」

> - [前端进阶｜重学「从URL输入到页面渲染」](https://juejin.cn/post/7078245863214039071)
> - [浏览器渲染的那些事(一)](https://segmentfault.com/a/1190000005169412)
> - [前端都该懂的浏览器工作原理，你懂了吗？](https://segmentfault.com/a/1190000022633988)

浏览器是多进程的工作的，“从URL输入到渲染”会主要涉及到的，是浏览器进程、网络进程和渲染进程这三个：

浏览器进程负责处理、响应用户交互，比如点击、滚动；
网络进程负责处理数据的请求，提供下载功能；
渲染进程负责将获取到的HTML、CSS、JS处理成可以看见、可以交互的页面；

“从URL输入到页面渲染”整个过程可以分成网络请求和浏览器渲染两个部分，分别由网络进程和渲染进程去处理。

## 网络请求

### URL 解析

encodeURI和 encodeURIComponent正是起这个作用的，它们的规则基本一样，只是= ? & ; /这类URI组成符号，这些在encodeURI中不会被编码，但在encodeURIComponent中统统会

### 检查缓存

- 检查强缓存，有的话返回200，size=momery cache或者是disk cache
- 没有强缓存的化，带着缓存标志向浏览器发起请求，检查是否能继续使用。可以继续使用的话返回304，否则返回200并返回更新的资源。

### DNS 解析

- 浏览器 DNS 缓存
- 操作系统的 DNS 缓存
- 路由器的 DNS 缓存
- 运营商 DNS 服务器查询
- 根域名查询

```html
<link rel="dns-prefetch" href="http://www.baidu.com" />
```

### 建立 TCP 连接

三次握手

三次握手是为了保证客户端存活,防止服务端在收到失效的超时请求造成资源浪费。

### TLS 握手

- 客户端发送随机数，以及需要的协议和加密方式
- 服务端接受随机值，发送自己的数字证书，附加自己的随机值，并根据客户端需求的协议和加密方式使用对应的方式
- 客户端接收证书并验证是否有效，验证通过后会再生成一个随机值，并通过服务端证书的公钥加密，发送给服务端
- 服务器收到加密后的随机值，并使用私钥解密获取第三个随机值，这是两端都有了三个随机值通过这三个随机值约定的加密方式生成密钥

TLS握手时是非对称加密来通信，正式传输数据时，使用对称加密的方式。

### 发送请求 && 接收响应

### 关闭 TCP 连接

四次挥手

TCP 是可以双向传输数据的，每个方向都需要一个请求和一个确认。所以双方都需要确认关闭。

主动方会多等待 2MSL，这是一种兜底机制。

## 浏览器渲染

### 构建 DOM 树

HTML文件的结构没法直接被浏览器使用，所以需要先把HTML标签变成可以给js使用的结构

### 样式计算

- 通过 link 引用的外部 css
- style 标签内的样式
- 元素 style 属性内嵌的css

问题1：为什么 css 放在头部，js 放在 body 尾部？

css 资源异步下载，下载和解析不会阻塞构建 dom 树
js 资源同步下载，下载和执行都会阻塞构建 dom 树

问题2：js脚本引入时async和defer有什么差别

- 没有 defer 或 async，浏览器会立即加载并执行指定的脚本
- async 属性表示异步执行引入的 JavaScript，经加载好，就会开始执行，无顺序
- defer 属性表示延迟到DOM解析完成，再执行引入的 JS，有顺序的执行

问题3：preload、prefetch有什么区别

- preload：以高优先级为当前页面加载资源；
- prefetch：以低优先级为后面的页面加载未来需要的资源，只会在空闲时才去加载；

为了保证资源的正确的预加载

- preload的资源应该在当前页面立即使用，如果不加上script标签执行预加载的资源，控制台中会显示警告，提示预加载的资源在当前页面没有被引用；
- prefetch的目的是取未来会使用的资源，所以当用户从A页面跳转到B页面时，进行中的preload的资源会被中断，而prefetch不会；
- 使用preload时，应配合as属性，表示该资源的优先级，使用 as="style" 属性将获得最高的优先级，as ="script"将获得低优先级或中优先级，其他可以取的值有font/image/audio/video；
- preload字体时要加上crossorigin属性，即使没有跨域，否则会重复加载：

### 布局定位 Layout

布局树只取渲染树中的可见元素，意味着head标签，display:none的元素不会被添加。

### 图层分层

### 图层绘制 Paint

